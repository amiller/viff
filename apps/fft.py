import random
import time
from viff.field import GF
from viff.util import rand


def get_omega(field, n):
    """
    Given a field, this method returns an nth root of unity.
    """
    p = field.modulus
    x = field(rand.randint(0, p-1))
    y = pow(x, (p-1)//n)
    if y == 1:
        return get_omega(p, n)
    assert pow(y, n) == 1
    return y


def fft_helper(A, omega):
    """
    Given coefficients A of polynomial this method does FFT and returns
    the evaluation of the polynomial at [omega^0, omega^(n-1)]

    If the polynomial is a0*x^0 + a1*x^1 + ... + an*x^n then the coefficients
    list is of the form [a0, a1, ... , an].
    """
    n = len(A)
    # Check if n is a power of 2.
    assert not (n & (n-1))

    if n == 1:
        return A

    B = A[0::2]
    C = A[1::2]
    B_bar = fft_helper(B, pow(omega, 2))
    C_bar = fft_helper(C, pow(omega, 2))
    A_bar = [0]*(n)
    for j in range(n):
        k = (j % (n//2))
        A_bar[j] = B_bar[k] + ((pow(omega, j))*C_bar[k])
    return A_bar


def generate_polynomial(n):
    """
    Returns a list of coefficients denoting a polynomial.
    If the polynomial is a0*x^0 + a1*x^1 + ... + an*x^n then the output list
    is of the form [a0, a1, ... , an].

    """
    return [random.randint(0, i) for i in range(random.randint(1, n))]


def test_correctness(coefficients, omega, fft_helper_result):
    """
    This method verifies the output generated by FFT by evaluating
    the polynomial at the coefficients.

    In order to save time, it verifies only 100 points from the FFT output
    after evaluating them at the coefficients.
    """
    assert len(coefficients) == len(fft_helper_result)
    n = len(fft_helper_result)

    # Test on 100 random points
    points = [random.randint(0, n) for i in range(100)]
    c = 0
    for i in points:
        y = 0
        for k in range(n):
            if coefficients[k] != 0:
                y = y + (coefficients[k] * pow(omega, i*k))
                # print("####", y, coefficients[k], pow(omega, i*k), k)
        # print(y, fft_helper_result[i], i)
        c += 1
        print(c, "points verfied")
        assert y == fft_helper_result[i]

# This `r` is the order of BLS12-381, also the base field of 
# the JubJub curve. `n` is a large power of 2 that divides `(r-1)` 
r = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001
n = pow(2, 17)
Zp = GF(r)

coefficients = generate_polynomial(1000)
padded_coefficients = coefficients + ([0] * (n-len(coefficients)))
# print(len(padded_coefficients), n)

s = time.time()
omega = get_omega(Zp, n)
e = time.time()
print("OMEGA", omega, "TIME:", e - s)

s = time.time()
output = fft_helper(padded_coefficients, omega)
e = time.time()
print("FFT completed", "TIME:", e - s)
test_correctness(padded_coefficients, omega, output)