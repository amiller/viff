import random
import time
from viff.field import GF
import random
import sys

def get_omega(field, n, seed = None):
    """
    Given a field, this method returns an nth root of unity.
    If the seed is not None then this method will return the
    same n'th root of unity for every run with the same seed.
    """
    p = field.modulus
    if seed is not None:
        random.seed(seed)
    x = field(random.randint(0, p-1))
    y = pow(x, (p-1)//n)
    if y == 1:
        return get_omega(p, n)
    assert pow(y, n) == 1
    return y

def fft_helper(A, omega, field):
    """
    Given coefficients A of polynomial this method does FFT and returns
    the evaluation of the polynomial at [omega^0, omega^(n-1)]

    If the polynomial is a0*x^0 + a1*x^1 + ... + an*x^n then the coefficients
    list is of the form [a0, a1, ... , an].
    """
    n = len(A)

    # Check if n is a power of 2.
    assert not (n & (n-1))

    if n == 1:
        return A

    B = A[0::2]
    C = A[1::2]
    B_bar = fft_helper(B, pow(omega, 2), field)
    C_bar = fft_helper(C, pow(omega, 2), field)
    A_bar = [field(1)]*(n)
    for j in range(n):
        k = (j % (n//2))
        A_bar[j] = B_bar[k] + int(pow(omega, j)) * C_bar[k]
    return A_bar

def fft(coefficients, n = None, seed = None, Zp = None, test = False,
            enable_profiling = False):

    if Zp is None:
        # This `r` is the order of BLS12-381, also the base field of
        # the JubJub curve.
        Zp = GF(0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001)
    if n is None:
        # `n` is a large power of 2 that divides `(r-1)`
        n = pow(2, 17)
        assert (Zp.modulus - 1) % n == 0

    padded_coefficients = coefficients + ([0] * (n-len(coefficients)))

    s = time.time()
    omega = get_omega(Zp, n, seed)
    e = time.time()

    if enable_profiling:
        print("OMEGA", omega, "TIME:", e - s)

    s = time.time()
    output = fft_helper(padded_coefficients, omega, Zp)
    e = time.time()

    if enable_profiling:
        print("FFT completed", "TIME:", e - s)

    if test:
        test_correctness(padded_coefficients, omega, output)

    return output

def generate_polynomial(n, field):
    """
    Returns a list of coefficients denoting a polynomial.
    If the polynomial is a0*x^0 + a1*x^1 + ... + an*x^n then the output list
    is of the form [a0, a1, ... , an].

    """
    return [field(random.randint(0, i)) for i in range(random.randint(1, n))]


def test_correctness(coefficients, omega, fft_helper_result):
    """
    This method verifies the output generated by FFT by evaluating
    the polynomial at the coefficients.

    In order to save time, it verifies only 100 points from the FFT output
    after evaluating them at the coefficients.
    """
    assert len(coefficients) == len(fft_helper_result)
    n = len(fft_helper_result)

    # Test on 100 random points
    total_verification_points = 100
    points = [random.randint(0, n) for i in range(total_verification_points)]
    c = 0
    for i in points:
        y = 0
        for k in range(n):
            if coefficients[k] != 0:
                y = y + (coefficients[k] * pow(omega, i*k))
        
        c += 1
        sys.stdout.write("%d / %d points verified!"%(c,
                            total_verification_points))

        char = "\r" if c < len(points) else "\n"
        sys.stdout.write(char)

        sys.stdout.flush()

        assert y == fft_helper_result[i]


if __name__ == "__main__":
    Zp = GF(0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001)
    coefficients = generate_polynomial(1000, Zp)
    fft(coefficients, n=1024, test=True, enable_profiling=True)